{"version":3,"file":"tree.es.js","sources":["../src/tree.ts"],"sourcesContent":["import {Parser} from \"./parse\"\n\n// FIXME profile adding a per-Tree TreeNode cache, validating it by\n// parent pointer\n\n/// The default maximum length of a `TreeBuffer` node (1024).\nexport const DefaultBufferLength = 1024\n\nlet nextPropID = 0\n\nexport class Range {\n  constructor(readonly from: number, readonly to: number) {}\n}\n\n/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)\n/// can have metadata associated with it in props. Instances of this\n/// class represent prop names.\nexport class NodeProp<T> {\n  /// @internal\n  id: number\n\n  /// Indicates whether this prop is stored per [node\n  /// type](#common.NodeType) or per [tree node](#common.Tree).\n  perNode: boolean\n\n  /// A method that deserializes a value of this prop from a string.\n  /// Can be used to allow a prop to be directly written in a grammar\n  /// file.\n  deserialize: (str: string) => T\n\n  /// Create a new node prop type.\n  constructor(config: {\n    /// The [deserialize](#common.NodeProp.deserialize) function to use\n    /// for this prop. Defaults to a funciton that raises an error.\n    deserialize?: (str: string) => T,\n    /// By default, node props are stored in the [node\n    /// type](#common.NodeType). It can sometimes be useful to directly\n    /// store information (usually related to the parsing algorithm)\n    /// in [nodes](#common.Tree) themselves. Set this to true to enable\n    /// that for this prop.\n    perNode?: boolean\n  } = {}) {\n    this.id = nextPropID++\n    this.perNode = !!config.perNode\n    this.deserialize = config.deserialize || (() => {\n      throw new Error(\"This node type doesn't define a deserialize function\")\n    })\n  }\n\n  /// This is meant to be used with\n  /// [`NodeSet.extend`](#common.NodeSet.extend) or\n  /// [`LRParser.configure`](#lr.ParserConfig.props) to compute\n  /// prop values for each node type in the set. Takes a [match\n  /// object](#common.NodeType^match) or function that returns undefined\n  /// if the node type doesn't get this prop, and the prop's value if\n  /// it does.\n  add(match: {[selector: string]: T} | ((type: NodeType) => T | undefined)): NodePropSource {\n    if (this.perNode) throw new RangeError(\"Can't add per-node props to node types\")\n    if (typeof match != \"function\") match = NodeType.match(match)\n    return (type) => {\n      let result = (match as (type: NodeType) => T | undefined)(type)\n      return result === undefined ? null : [this, result]\n    }\n  }\n\n  /// Prop that is used to describe matching delimiters. For opening\n  /// delimiters, this holds an array of node names (written as a\n  /// space-separated string when declaring this prop in a grammar)\n  /// for the node types of closing delimiters that match it.\n  static closedBy = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n\n  /// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is\n  /// attached to closing delimiters, holding an array of node names\n  /// of types of matching opening delimiters.\n  static openedBy = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n\n  /// Used to assign node types to groups (for example, all node\n  /// types that represent an expression could be tagged with an\n  /// `\"Expression\"` group).\n  static group = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n\n  /// The hash of the [context](#lr.ContextTracker.constructor)\n  /// that the node was parsed in, if any. Used to limit reuse of\n  /// contextual nodes.\n  static contextHash = new NodeProp<number>({perNode: true})\n\n  /// The distance beyond the end of the node that the tokenizer\n  /// looked ahead for any of the tokens inside the node. (The LR\n  /// parser only stores this when it is larger than 25, for\n  /// efficiency reasons.)\n  static lookAhead = new NodeProp<number>({perNode: true})\n\n  /// This per-node prop is used to replace a given node, or part of a\n  /// node, with another tree. This is useful to include trees from\n  /// different languages.\n  static mounted = new NodeProp<MountedTree>({perNode: true})\n}\n\n/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on\n/// a tree node to indicate that parts of its content are\n/// represented by another tree.\nexport class MountedTree {\n  constructor(\n    /// The inner tree.\n    readonly tree: Tree,\n    /// If this is null, this tree replaces the entire node (it will\n    /// be included in the regular iteration instead of its host\n    /// node). If not, only the given ranges are considered to be\n    /// covered by this tree. This is used for trees that are mixed in\n    /// a way that isn't strictly hierarchical. Such mounted trees are\n    /// only entered by [`resolveInner`](#common.Tree.resolveInner)\n    /// and [`enter`](#common.SyntaxNode.enter).\n    readonly overlay: readonly {from: number, to: number}[] | null,\n    /// The parser used to create this subtree.\n    readonly parser: Parser\n  ) {}\n}\n\n/// Type returned by [`NodeProp.add`](#common.NodeProp.add). Describes\n/// whether a prop should be added to a given node type in a node set,\n/// and what value it should have.\nexport type NodePropSource = (type: NodeType) => null | [NodeProp<any>, any]\n\n// Note: this is duplicated in lr/src/constants.ts\nconst enum NodeFlag {\n  Top = 1,\n  Skipped = 2,\n  Error = 4,\n  Anonymous = 8\n}\n\nconst noProps: {[propID: number]: any} = Object.create(null)\n\n/// Each node in a syntax tree has a node type associated with it.\nexport class NodeType {\n  /// @internal\n  constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    readonly name: string,\n    /// @internal\n    readonly props: {readonly [prop: number]: any},\n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    readonly id: number,\n    /// @internal\n    readonly flags: number = 0) {}\n\n  static define(spec: {\n    /// The ID of the node type. When this type is used in a\n    /// [set](#common.NodeSet), the ID must correspond to its index in\n    /// the type array.\n    id: number, \n    /// The name of the node type. Leave empty to define an anonymous\n    /// node.\n    name?: string,\n    /// [Node props](#common.NodeProp) to assign to the type. The value\n    /// given for any given prop should correspond to the prop's type.\n    props?: readonly ([NodeProp<any>, any] | NodePropSource)[],\n    /// Whether this is a [top node](#common.NodeType.isTop).\n    top?: boolean,\n    /// Whether this node counts as an [error\n    /// node](#common.NodeType.isError).\n    error?: boolean,\n    /// Whether this node is a [skipped](#common.NodeType.isSkipped)\n    /// node.\n    skipped?: boolean\n  }) {\n    let props = spec.props && spec.props.length ? Object.create(null) : noProps\n    let flags = (spec.top ? NodeFlag.Top : 0) | (spec.skipped ? NodeFlag.Skipped : 0) |\n      (spec.error ? NodeFlag.Error : 0) | (spec.name == null ? NodeFlag.Anonymous : 0)\n    let type = new NodeType(spec.name || \"\", props, spec.id, flags)\n    if (spec.props) for (let src of spec.props) {\n      if (!Array.isArray(src)) src = src(type)!\n      if (src) {\n        if (src[0].perNode) throw new RangeError(\"Can't store a per-node prop on a node type\")\n        props[src[0].id] = src[1]\n      }\n    }\n    return type\n  }\n\n  /// Retrieves a node prop for this type. Will return `undefined` if\n  /// the prop isn't present on this node.\n  prop<T>(prop: NodeProp<T>): T | undefined { return this.props[prop.id] }\n\n  /// True when this is the top node of a grammar.\n  get isTop() { return (this.flags & NodeFlag.Top) > 0 }\n\n  /// True when this node is produced by a skip rule.\n  get isSkipped() { return (this.flags & NodeFlag.Skipped) > 0 }\n\n  /// Indicates whether this is an error node.\n  get isError() { return (this.flags & NodeFlag.Error) > 0 }\n\n  /// When true, this node type doesn't correspond to a user-declared\n  /// named node, for example because it is used to cache repetition.\n  get isAnonymous() { return (this.flags & NodeFlag.Anonymous) > 0 }\n\n  /// Returns true when this node's name or one of its\n  /// [groups](#common.NodeProp^group) matches the given string.\n  is(name: string | number) {\n    if (typeof name == 'string') {\n      if (this.name == name) return true\n      let group = this.prop(NodeProp.group)\n      return group ? group.indexOf(name) > -1 : false\n    }\n    return this.id == name\n  }\n\n  /// An empty dummy node type to use when no actual type is available.\n  static none: NodeType = new NodeType(\"\", Object.create(null), 0, NodeFlag.Anonymous)\n\n  /// Create a function from node types to arbitrary values by\n  /// specifying an object whose property names are node or\n  /// [group](#common.NodeProp^group) names. Often useful with\n  /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n  /// names, separated by spaces, in a single property name to map\n  /// multiple node names to a single value.\n  static match<T>(map: {[selector: string]: T}): (node: NodeType) => T | undefined {\n    let direct = Object.create(null)\n    for (let prop in map)\n      for (let name of prop.split(\" \")) direct[name] = map[prop]\n    return (node: NodeType) => {\n      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n        let found = direct[i < 0 ? node.name : groups![i]]\n        if (found) return found\n      }\n    }\n  }\n}\n\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a numeric array. Each parser\n/// [has](#lr.LRParser.nodeSet) a node set, and [tree\n/// buffers](#common.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536) node\n/// types in it, so that the ids fit into 16-bit typed array slots.\nexport class NodeSet {\n  /// Create a set with the given types. The `id` property of each\n  /// type should correspond to its position within the array.\n  constructor(\n    /// The node types in this set, by id.\n    readonly types: readonly NodeType[]\n  ) {\n    for (let i = 0; i < types.length; i++) if (types[i].id != i)\n      throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\")\n  }\n\n  /// Create a copy of this set with some node properties added. The\n  /// arguments to this method should be created with\n  /// [`NodeProp.add`](#common.NodeProp.add).\n  extend(...props: NodePropSource[]): NodeSet {\n    let newTypes: NodeType[] = []\n    for (let type of this.types) {\n      let newProps: null | {[id: number]: any} = null\n      for (let source of props) {\n        let add = source(type)\n        if (add) {\n          if (!newProps) newProps = Object.assign({}, type.props)\n          newProps[add[0].id] = add[1]\n        }\n      }\n      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type)\n    }\n    return new NodeSet(newTypes)\n  }\n}\n\nconst CachedNode = new WeakMap<Tree, TreeNode>()\n\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the [`TreeCursor`](#common.TreeCursor) or\n/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\n/// a view on some part of this data structure, and can be used to\n/// move around to adjacent nodes.\nexport class Tree {\n  /// @internal\n  props: null | {[id: number]: any} = null\n\n  /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n  constructor(\n    /// The type of the top node.\n    readonly type: NodeType,\n    /// This node's child nodes.\n    readonly children: readonly (Tree | TreeBuffer)[],\n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    readonly positions: readonly number[],\n    /// The total length of this tree\n    readonly length: number,\n    /// Per-node [node props](#common.NodeProp) to associate with this node.\n    props?: readonly [NodeProp<any> | number, any][]\n  ) {\n    if (props && props.length) {\n      this.props = Object.create(null)\n      for (let [prop, value] of props) this.props![typeof prop == \"number\" ? prop : prop.id] = value\n    }\n  }\n\n  /// @internal\n  toString(): string {\n    let mounted = this.prop(NodeProp.mounted)\n    if (mounted && !mounted.overlay) return mounted.tree.toString()\n    let children = \"\"\n    for (let ch of this.children) {\n      let str = ch.toString()\n      if (str) {\n        if (children) children += \",\"\n        children += str\n      }\n    }\n    return !this.type.name ? children :\n      (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n      (children.length ? \"(\" + children + \")\" : \"\")\n  }\n\n  /// The empty tree\n  static empty = new Tree(NodeType.none, [], [], 0)\n\n  /// Get a [tree cursor](#common.TreeCursor) rooted at this tree. When\n  /// `pos` is given, the cursor is [moved](#common.TreeCursor.moveTo)\n  /// to the given position and side.\n  cursor(pos?: number, side: -1 | 0 | 1 = 0): TreeCursor {\n    let scope = (pos != null && CachedNode.get(this)) || (this.topNode as TreeNode)\n    let cursor = new TreeCursor(scope)\n    if (pos != null) {\n      cursor.moveTo(pos, side)\n      CachedNode.set(this, cursor._tree)\n    }\n    return cursor\n  }\n\n  /// Get a [tree cursor](#common.TreeCursor) that, unlike regular\n  /// cursors, doesn't skip through\n  /// [anonymous](#common.NodeType.isAnonymous) nodes and doesn't\n  /// automatically enter mounted nodes.\n  fullCursor(): TreeCursor {\n    return new TreeCursor(this.topNode as TreeNode, Mode.Full)\n  }\n\n  /// Get a [syntax node](#common.SyntaxNode) object for the top of the\n  /// tree.\n  get topNode(): SyntaxNode {\n    return new TreeNode(this, 0, 0, null)\n  }\n\n  /// Get the [syntax node](#common.SyntaxNode) at the given position.\n  /// If `side` is -1, this will move into nodes that end at the\n  /// position. If 1, it'll move into nodes that start at the\n  /// position. With 0, it'll only enter nodes that cover the position\n  /// from both sides.\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor(pos, side).node\n  }\n\n  /// Like [`resolve`](#common.Tree.resolve), but will enter\n  /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n  /// pointing into the innermost overlaid tree at the given position\n  /// (with parent links going through all parent structure, including\n  /// the host trees).\n  resolveInner(pos: number, side: -1 | 0 | 1 = 0) {\n    let result = this.topNode\n    for (;;) {\n      let inner = result.enter(pos, side)\n      if (!inner) return result\n      result = inner\n    }\n  }\n\n  /// Iterate over the tree and its children, calling `enter` for any\n  /// node that touches the `from`/`to` region (if given) before\n  /// running over such a node's children, and `leave` (if given) when\n  /// leaving the node. When `enter` returns `false`, that node will\n  /// not have its children iterated over (or `leave` called).\n  iterate(spec: {\n    enter(type: NodeType, from: number, to: number, get: () => SyntaxNode): false | void,\n    leave?(type: NodeType, from: number, to: number, get: () => SyntaxNode): void,\n    from?: number,\n    to?: number\n  }) {\n    let {enter, leave, from = 0, to = this.length} = spec\n    for (let c = this.cursor(), get = () => c.node;;) {\n      let mustLeave = false\n      if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to, get) !== false)) {\n        if (c.firstChild()) continue\n        if (!c.type.isAnonymous) mustLeave = true\n      }\n      for (;;) {\n        if (mustLeave && leave) leave(c.type, c.from, c.to, get)\n        mustLeave = c.type.isAnonymous\n        if (c.nextSibling()) break\n        if (!c.parent()) return\n        mustLeave = true\n      }\n    }\n  }\n\n  /// Get the value of the given [node prop](#common.NodeProp) for this\n  /// node. Works with both per-node and per-type props.\n  prop<T>(prop: NodeProp<T>): T | undefined {\n    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined\n  }\n\n  /// Returns the node's [per-node props](#common.NodeProp.perNode) in a\n  /// format that can be passed to the [`Tree`](#common.Tree)\n  /// constructor.\n  get propValues(): readonly [NodeProp<any> | number, any][] {\n    let result: [NodeProp<any> | number, any][] = []\n    if (this.props) for (let id in this.props) result.push([+id, this.props[id]])\n    return result\n  }\n\n  /// Balance the direct children of this tree, producing a copy of\n  /// which may have children grouped into subtrees with type\n  /// [`NodeType.none`](#common.NodeType^none).\n  balance(config: {\n    /// Function to create the newly balanced subtrees.\n    makeTree?: (children: readonly (Tree | TreeBuffer)[], positions: readonly number[], length: number) => Tree\n  } = {}) {\n    return this.children.length <= Balance.BranchFactor ? this :\n      balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length,\n                   (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues),\n                   config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)))\n  }\n\n  /// Build a tree from a postfix-ordered buffer of node information,\n  /// or a cursor over such a buffer.\n  static build(data: BuildData) { return buildTree(data) }\n}\n\ntype BuildData = {\n  /// The buffer or buffer cursor to read the node data from.\n  ///\n  /// When this is an array, it should contain four values for every\n  /// node in the tree.\n  ///\n  ///  - The first holds the node's type, as a node ID pointing into\n  ///    the given `NodeSet`.\n  ///  - The second holds the node's start offset.\n  ///  - The third the end offset.\n  ///  - The fourth the amount of space taken up in the array by this\n  ///    node and its children. Since there's four values per node,\n  ///    this is the total number of nodes inside this node (children\n  ///    and transitive children) plus one for the node itself, times\n  ///    four.\n  ///\n  /// Parent nodes should appear _after_ child nodes in the array. As\n  /// an example, a node of type 10 spanning positions 0 to 4, with\n  /// two children, of type 11 and 12, might look like this:\n  ///\n  ///     [11, 0, 1, 4, 12, 2, 4, 4, 10, 0, 4, 12]\n  buffer: BufferCursor | readonly number[],\n  /// The node types to use.\n  nodeSet: NodeSet,\n  /// The id of the top node type, if any.\n  topID: number,\n  /// The position the tree should start at. Defaults to 0.\n  start?: number,\n  /// The position in the buffer where the function should stop\n  /// reading. Defaults to 0.\n  bufferStart?: number,\n  /// The length of the wrapping node. The end offset of the last\n  /// child is used when not provided.\n  length?: number,\n  /// The maximum buffer length to use. Defaults to\n  /// [`DefaultBufferLength`](#common.DefaultBufferLength).\n  maxBufferLength?: number,\n  /// An optional array holding reused nodes that the buffer can refer\n  /// to.\n  reused?: readonly Tree[],\n  /// The first node type that indicates repeat constructs in this\n  /// grammar.\n  minRepeatType?: number\n}\n\n/// This is used by `Tree.build` as an abstraction for iterating over\n/// a tree buffer. A cursor initially points at the very last element\n/// in the buffer. Every time `next()` is called it moves on to the\n/// previous one.\nexport interface BufferCursor {\n  /// The current buffer position (four times the number of nodes\n  /// remaining).\n  pos: number\n  /// The node ID of the next node in the buffer.\n  id: number\n  /// The start position of the next node in the buffer.\n  start: number\n  /// The end position of the next node.\n  end: number\n  /// The size of the next node (the number of nodes inside, counting\n  /// the node itself, times 4).\n  size: number\n  /// Moves `this.pos` down by 4.\n  next(): void\n  /// Create a copy of this cursor.\n  fork(): BufferCursor\n}\n\nclass FlatBufferCursor implements BufferCursor {\n  constructor(readonly buffer: readonly number[], public index: number) {}\n\n  get id() { return this.buffer[this.index - 4] }\n  get start() { return this.buffer[this.index - 3] }\n  get end() { return this.buffer[this.index - 2] }\n  get size() { return this.buffer[this.index - 1] }\n\n  get pos() { return this.index }\n\n  next() { this.index -= 4 }\n\n  fork() { return new FlatBufferCursor(this.buffer, this.index) }\n}\n\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\nexport class TreeBuffer {\n  /// Create a tree buffer.\n  constructor(\n    /// The buffer's content.\n    readonly buffer: Uint16Array,\n    /// The total length of the group of nodes in the buffer.\n    readonly length: number,\n    /// The node set used in this buffer.\n    readonly set: NodeSet\n  ) {}\n\n  /// @internal\n  get type() { return NodeType.none }\n\n  /// @internal\n  toString() {\n    let result: string[] = []\n    for (let index = 0; index < this.buffer.length;) {\n      result.push(this.childString(index))\n      index = this.buffer[index + 3]\n    }\n    return result.join(\",\")\n  }\n\n  /// @internal\n  childString(index: number): string {\n    let id = this.buffer[index], endIndex = this.buffer[index + 3]\n    let type = this.set.types[id], result = type.name\n    if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result)\n    index += 4\n    if (endIndex == index) return result\n    let children: string[] = []\n    while (index < endIndex) {\n      children.push(this.childString(index))\n      index = this.buffer[index + 3]\n    }\n    return result + \"(\" + children.join(\",\") + \")\"\n  }\n\n  /// @internal\n  findChild(startIndex: number, endIndex: number, dir: 1 | -1, pos: number, side: Side) {\n    let {buffer} = this, pick = -1\n    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n        pick = i\n        if (dir > 0) break\n      }\n    }\n    return pick\n  }\n\n  /// @internal\n  slice(startI: number, endI: number, from: number, to: number) {\n    let b = this.buffer\n    let copy = new Uint16Array(endI - startI)\n    for (let i = startI, j = 0; i < endI;) {\n      copy[j++] = b[i++]\n      copy[j++] = b[i++] - from\n      copy[j++] = b[i++] - from\n      copy[j++] = b[i++] - startI\n    }\n    return new TreeBuffer(copy, to - from, this.set)\n  }\n}\n\n/// A syntax node provides an immutable pointer to a given node in a\n/// tree. When iterating over large amounts of nodes, you may want to\n/// use a mutable [cursor](#common.TreeCursor) instead, which is more\n/// efficient.\nexport interface SyntaxNode {\n  /// The type of the node.\n  type: NodeType\n  /// The name of the node (`.type.name`).\n  name: string\n  /// The start position of the node.\n  from: number\n  /// The end position of the node.\n  to: number\n\n  /// The node's parent node, if any.\n  parent: SyntaxNode | null\n  /// The first child, if the node has children.\n  firstChild: SyntaxNode | null\n  /// The node's last child, if available.\n  lastChild: SyntaxNode | null\n  /// The first child that ends after `pos`.\n  childAfter(pos: number): SyntaxNode | null\n  /// The last child that starts before `pos`.\n  childBefore(pos: number): SyntaxNode | null\n  /// Enter the child at the given position. If side is -1 the child\n  /// may end at that position, when 1 it may start there.\n  ///\n  /// This will by default enter\n  /// [overlaid](#common.MountedTree.overlay)\n  /// [mounted](#common.NodeProp^mounted) trees. You can set\n  /// `overlays` to false to disable that.\n  ///\n  /// Similarly, when `buffers` is false this will not enter\n  /// [buffers](#common.TreeBuffer), only [nodes](#common.Tree) (which\n  /// is mostly useful when looking for props, which cannot exist on\n  /// buffer-allocated nodes).\n  enter(pos: number, side: -1 | 0 | 1, overlays?: boolean, buffers?: boolean): SyntaxNode | null\n  /// This node's next sibling, if any.\n  nextSibling: SyntaxNode | null\n  /// This node's previous sibling.\n  prevSibling: SyntaxNode | null\n  /// A [tree cursor](#common.TreeCursor) starting at this node.\n  cursor: TreeCursor\n  /// Find the node around, before (if `side` is -1), or after (`side`\n  /// is 1) the given position. Will look in parent nodes if the\n  /// position is outside this node.\n  resolve(pos: number, side?: -1 | 0 | 1): SyntaxNode\n  /// Move the position to the innermost node before `pos` that looks\n  /// like it is unfinished (meaning it ends in an error node or has a\n  /// child ending in an error node right at its end).\n  enterUnfinishedNodesBefore(pos: number): SyntaxNode\n  /// Get the [tree](#common.Tree) that represents the current node, if\n  /// any. Will return null when the node is in a [tree\n  /// buffer](#common.TreeBuffer).\n  tree: Tree | null\n  /// Get a [tree](#common.Tree) for this node. Will allocate one if it\n  /// points into a buffer.\n  toTree(): Tree\n\n  /// Get the first child of the given type (which may be a [node\n  /// name](#common.NodeType.name) or a [group\n  /// name](#common.NodeProp^group)). If `before` is non-null, only\n  /// return children that occur somewhere after a node with that name\n  /// or group. If `after` is non-null, only return children that\n  /// occur somewhere before a node with that name or group.\n  getChild(type: string | number, before?: string | number | null, after?: string | number | null): SyntaxNode | null\n\n  /// Like [`getChild`](#common.SyntaxNode.getChild), but return all\n  /// matching children, not just the first.\n  getChildren(type: string | number, before?: string | number | null, after?: string | number | null): SyntaxNode[]\n}\n\nconst enum Side {\n  Before = -2,\n  AtOrBefore = -1,\n  Around = 0,\n  AtOrAfter = 1,\n  After = 2,\n  DontCare = 4\n}\n\nfunction checkSide(side: Side, pos: number, from: number, to: number) {\n  switch (side) {\n    case Side.Before: return from < pos\n    case Side.AtOrBefore: return to >= pos && from < pos\n    case Side.Around: return from < pos && to > pos\n    case Side.AtOrAfter: return from <= pos && to > pos\n    case Side.After: return to > pos\n    case Side.DontCare: return true\n  }\n}\n\nexport const enum Mode {\n  Full = 1,\n  NoEnterBuffer = 2,\n}\n\nfunction enterUnfinishedNodesBefore(node: SyntaxNode, pos: number) {\n  let scan = node.childBefore(pos)\n  while (scan) {\n    let last = scan.lastChild\n    if (!last || last.to != scan.to) break\n    if (last.type.isError && last.from == last.to) {\n      node = scan\n      scan = last.prevSibling\n    } else {\n      scan = last\n    }\n  }\n  return node\n}\n\nexport class TreeNode implements SyntaxNode {\n  constructor(readonly node: Tree,\n              readonly _from: number,\n              // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n              readonly index: number,\n              readonly _parent: TreeNode | null) {}\n\n  get type() { return this.node.type }\n\n  get name() { return this.node.type.name }\n\n  get from() { return this._from }\n\n  get to() { return this._from + this.node.length }\n\n  nextChild(i: number, dir: 1 | -1, pos: number, side: Side, mode: Mode = 0): TreeNode | BufferNode | null {\n    for (let parent: TreeNode = this;;) {\n      for (let {children, positions} = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n        let next = children[i], start = positions[i] + parent._from\n        if (!checkSide(side, pos, start, start + next.length)) continue\n        if (next instanceof TreeBuffer) {\n          if (mode & Mode.NoEnterBuffer) continue\n          let index = next.findChild(0, next.buffer.length, dir, pos - start, side)\n          if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index)\n        } else if ((mode & Mode.Full) || (!next.type.isAnonymous || hasChild(next))) {\n          let mounted\n          if (!(mode & Mode.Full) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)\n            return new TreeNode(mounted.tree, start, i, parent)\n          let inner = new TreeNode(next, start, i, parent)\n          return (mode & Mode.Full) || !inner.type.isAnonymous ? inner\n            : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side)\n        }\n      }\n      if ((mode & Mode.Full) || !parent.type.isAnonymous) return null\n      if (parent.index >= 0) i = parent.index + dir\n      else i = dir < 0 ? -1 : parent._parent!.node.children.length\n      parent = parent._parent!\n      if (!parent) return null\n    }\n  }\n\n  get firstChild() { return this.nextChild(0, 1, 0, Side.DontCare) }\n  get lastChild() { return this.nextChild(this.node.children.length - 1, -1, 0, Side.DontCare) }\n\n  childAfter(pos: number) { return this.nextChild(0, 1, pos, Side.After) }\n  childBefore(pos: number) { return this.nextChild(this.node.children.length - 1, -1, pos, Side.Before) }\n\n  enter(pos: number, side: -1 | 0 | 1, overlays = true, buffers = true) {\n    let mounted\n    if (overlays && (mounted = this.node.prop(NodeProp.mounted)) && mounted.overlay) {\n      let rPos = pos - this.from\n      for (let {from, to} of mounted.overlay) {\n        if ((side > 0 ? from <= rPos : from < rPos) &&\n            (side < 0 ? to >= rPos : to > rPos))\n          return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this)\n      }\n    }\n    return this.nextChild(0, 1, pos, side, buffers ? 0 : Mode.NoEnterBuffer)\n  }\n\n  nextSignificantParent() {\n    let val: TreeNode = this\n    while (val.type.isAnonymous && val._parent) val = val._parent\n    return val\n  }\n\n  get parent() {\n    return this._parent ? this._parent.nextSignificantParent() : null\n  }\n\n  get nextSibling() {\n    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, Side.DontCare) : null\n  }\n  get prevSibling() {\n    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, Side.DontCare) : null\n  }\n\n  get cursor() { return new TreeCursor(this) }\n\n  get tree() { return this.node }\n\n  toTree() { return this.node }\n\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor.moveTo(pos, side).node\n  }\n\n  enterUnfinishedNodesBefore(pos: number) { return enterUnfinishedNodesBefore(this, pos) }\n\n  getChild(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    let r = getChildren(this, type, before, after)\n    return r.length ? r[0] : null\n  }\n\n  getChildren(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    return getChildren(this, type, before, after)\n  }\n\n  /// @internal\n  toString() { return this.node.toString() }\n}\n\nfunction getChildren(node: SyntaxNode, type: string | number, before: string | number | null, after: string | number | null): SyntaxNode[] {\n  let cur = node.cursor, result: SyntaxNode[] = []\n  if (!cur.firstChild()) return result\n  if (before != null) while (!cur.type.is(before)) if (!cur.nextSibling()) return result\n  for (;;) {\n    if (after != null && cur.type.is(after)) return result\n    if (cur.type.is(type)) result.push(cur.node)\n    if (!cur.nextSibling()) return after == null ? result : []\n  }\n}\n\nclass BufferContext {\n  constructor(readonly parent: TreeNode,\n              readonly buffer: TreeBuffer,\n              readonly index: number,\n              readonly start: number) {}\n}\n\nclass BufferNode implements SyntaxNode {\n  type: NodeType\n\n  get name() { return this.type.name }\n\n  get from() { return this.context.start + this.context.buffer.buffer[this.index + 1] }\n\n  get to() { return this.context.start + this.context.buffer.buffer[this.index + 2] }\n\n  constructor(readonly context: BufferContext,\n              readonly _parent: BufferNode | null,\n              readonly index: number) {\n    this.type = context.buffer.set.types[context.buffer.buffer[index]]\n  }\n\n  child(dir: 1 | -1, pos: number, side: Side): BufferNode | null {\n    let {buffer} = this.context\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side)\n    return index < 0 ? null : new BufferNode(this.context, this, index)\n  }\n\n  get firstChild() { return this.child(1, 0, Side.DontCare) }\n  get lastChild() { return this.child(-1, 0, Side.DontCare) }\n\n  childAfter(pos: number) { return this.child(1, pos, Side.After) }\n  childBefore(pos: number) { return this.child(-1, pos, Side.Before) }\n\n  enter(pos: number, side: -1 | 0 | 1, overlays?: boolean, buffers = true) {\n    if (!buffers) return null\n    let {buffer} = this.context\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side)\n    return index < 0 ? null : new BufferNode(this.context, this, index)\n  }\n\n  get parent() {\n    return this._parent || this.context.parent.nextSignificantParent()\n  }\n\n  externalSibling(dir: 1 | -1) {\n    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, Side.DontCare)\n  }\n\n  get nextSibling(): SyntaxNode | null {\n    let {buffer} = this.context\n    let after = buffer.buffer[this.index + 3]\n    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n      return new BufferNode(this.context, this._parent, after)\n    return this.externalSibling(1)\n  }\n\n  get prevSibling(): SyntaxNode | null {\n    let {buffer} = this.context\n    let parentStart = this._parent ? this._parent.index + 4 : 0\n    if (this.index == parentStart) return this.externalSibling(-1)\n    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, Side.DontCare))\n  }\n\n  get cursor() { return new TreeCursor(this) }\n\n  get tree() { return null }\n\n  toTree() {\n    let children = [], positions = []\n    let {buffer} = this.context\n    let startI = this.index + 4, endI = buffer.buffer[this.index + 3]\n    if (endI > startI) {\n      let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2]\n      children.push(buffer.slice(startI, endI, from, to))\n      positions.push(0)\n    }\n    return new Tree(this.type, children, positions, this.to - this.from)\n  }\n\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor.moveTo(pos, side).node\n  }\n\n  enterUnfinishedNodesBefore(pos: number) { return enterUnfinishedNodesBefore(this, pos) }\n\n  /// @internal\n  toString() { return this.context.buffer.childString(this.index) }\n\n  getChild(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    let r = getChildren(this, type, before, after)\n    return r.length ? r[0] : null\n  }\n\n  getChildren(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    return getChildren(this, type, before, after)\n  }\n}\n\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nexport class TreeCursor {\n  /// The node's type.\n  type!: NodeType\n\n  /// Shorthand for `.type.name`.\n  get name() { return this.type.name }\n\n  /// The start source offset of this node.\n  from!: number\n\n  /// The end source offset.\n  to!: number\n\n  /// @internal\n  _tree!: TreeNode\n  private buffer: BufferContext | null = null\n  private stack: number[] = []\n  private index: number = 0\n  private bufferNode: BufferNode | null = null\n\n  /// @internal\n  constructor(\n    node: TreeNode | BufferNode,\n    /// @internal\n    readonly mode = 0\n  ) {\n    if (node instanceof TreeNode) {\n      this.yieldNode(node)\n    } else {\n      this._tree = node.context.parent\n      this.buffer = node.context\n      for (let n: BufferNode | null = node._parent; n; n = n._parent) this.stack.unshift(n.index)\n      this.bufferNode = node\n      this.yieldBuf(node.index)\n    }\n  }\n\n  private yieldNode(node: TreeNode | null) {\n    if (!node) return false\n    this._tree = node\n    this.type = node.type\n    this.from = node.from\n    this.to = node.to\n    return true\n  }\n\n  private yieldBuf(index: number, type?: NodeType) {\n    this.index = index\n    let {start, buffer} = this.buffer!\n    this.type = type || buffer.set.types[buffer.buffer[index]]\n    this.from = start + buffer.buffer[index + 1]\n    this.to = start + buffer.buffer[index + 2]\n    return true\n  }\n\n  private yield(node: TreeNode | BufferNode | null) {\n    if (!node) return false\n    if (node instanceof TreeNode) {\n      this.buffer = null\n      return this.yieldNode(node)\n    }\n    this.buffer = node.context\n    return this.yieldBuf(node.index, node.type)\n  }\n\n  /// @internal\n  toString() {\n    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString()\n  }\n\n  /// @internal\n  enterChild(dir: 1 | -1, pos: number, side: Side) {\n    if (!this.buffer)\n      return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, pos, side, this.mode))\n\n    let {buffer} = this.buffer\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side)\n    if (index < 0) return false\n    this.stack.push(this.index)\n    return this.yieldBuf(index)\n  }\n\n  /// Move the cursor to this node's first child. When this returns\n  /// false, the node has no child, and the cursor has not been moved.\n  firstChild() { return this.enterChild(1, 0, Side.DontCare) }\n\n  /// Move the cursor to this node's last child.\n  lastChild() { return this.enterChild(-1, 0, Side.DontCare) }\n\n  /// Move the cursor to the first child that ends after `pos`.\n  childAfter(pos: number) { return this.enterChild(1, pos, Side.After) }\n\n  /// Move to the last child that starts before `pos`.\n  childBefore(pos: number) { return this.enterChild(-1, pos, Side.Before) }\n\n  /// Move the cursor to the child around `pos`. If side is -1 the\n  /// child may end at that position, when 1 it may start there. This\n  /// will also enter [overlaid](#common.MountedTree.overlay)\n  /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n  /// set to false.\n  enter(pos: number, side: -1 | 0 | 1, overlays = true, buffers = true) {\n    if (!this.buffer) return this.yield(this._tree.enter(pos, side, overlays && !(this.mode & Mode.Full), buffers))\n    return buffers ? this.enterChild(1, pos, side) : false\n  }\n\n  /// Move to the node's parent node, if this isn't the top node.\n  parent() {\n    if (!this.buffer) return this.yieldNode((this.mode & Mode.Full) ? this._tree._parent : this._tree.parent)\n    if (this.stack.length) return this.yieldBuf(this.stack.pop()!)\n    let parent = (this.mode & Mode.Full) ? this.buffer.parent : this.buffer.parent.nextSignificantParent()\n    this.buffer = null\n    return this.yieldNode(parent)\n  }\n\n  /// @internal\n  sibling(dir: 1 | -1) {\n    if (!this.buffer)\n      return !this._tree._parent ? false\n        : this.yield(this._tree.index < 0 ? null\n        : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, Side.DontCare, this.mode))\n\n    let {buffer} = this.buffer, d = this.stack.length - 1\n    if (dir < 0) {\n      let parentStart = d < 0 ? 0 : this.stack[d] + 4\n      if (this.index != parentStart)\n        return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, Side.DontCare))\n    } else {\n      let after = buffer.buffer[this.index + 3]\n      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n        return this.yieldBuf(after)\n    }\n    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, Side.DontCare, this.mode)) : false\n  }\n\n  /// Move to this node's next sibling, if any.\n  nextSibling() { return this.sibling(1) }\n\n  /// Move to this node's previous sibling, if any.\n  prevSibling() { return this.sibling(-1) }\n\n  private atLastNode(dir: 1 | -1) {\n    let index, parent: TreeNode | null, {buffer} = this\n    if (buffer) {\n      if (dir > 0) {\n        if (this.index < buffer.buffer.buffer.length) return false\n      } else {\n        for (let i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false\n      }\n      ;({index, parent} = buffer)\n    } else {\n      ({index, _parent: parent} = this._tree)\n    }\n    for (; parent; {index, _parent: parent} = parent) {\n      if (index > -1) for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {\n        let child = parent.node.children[i]\n        if ((this.mode & Mode.Full) || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false\n      }\n    }\n    return true\n  }\n\n  private move(dir: 1 | -1, enter: boolean) {\n    if (enter && this.enterChild(dir, 0, Side.DontCare)) return true\n    for (;;) {\n      if (this.sibling(dir)) return true\n      if (this.atLastNode(dir) || !this.parent()) return false\n    }\n  }\n\n  /// Move to the next node in a\n  /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n  /// traversal, going from a node to its first child or, if the\n  /// current node is empty or `enter` is false, its next sibling or\n  /// the next sibling of the first parent node that has one.\n  next(enter = true) { return this.move(1, enter) }\n\n  /// Move to the next node in a last-to-first pre-order traveral. A\n  /// node is followed by its last child or, if it has none, its\n  /// previous sibling or the previous sibling of the first parent\n  /// node that has one.\n  prev(enter = true) { return this.move(-1, enter) }\n\n  /// Move the cursor to the innermost node that covers `pos`. If\n  /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n  /// it will enter nodes that start at `pos`.\n  moveTo(pos: number, side: -1 | 0 | 1 = 0) {\n    // Move up to a node that actually holds the position, if possible\n    while (this.from == this.to ||\n           (side < 1 ? this.from >= pos : this.from > pos) ||\n           (side > -1 ? this.to <= pos : this.to < pos))\n      if (!this.parent()) break\n\n    // Then scan down into child nodes as far as possible\n    while (this.enterChild(1, pos, side)) {}\n    return this\n  }\n\n  /// Get a [syntax node](#common.SyntaxNode) at the cursor's current\n  /// position.\n  get node(): SyntaxNode {\n    if (!this.buffer) return this._tree\n    \n    let cache = this.bufferNode, result: BufferNode | null = null, depth = 0\n    if (cache && cache.context == this.buffer) {\n      scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n        for (let c: BufferNode | null = cache; c; c = c._parent) if (c.index == index) {\n          if (index == this.index) return c\n          result = c\n          depth = d + 1\n          break scan\n        }\n        index = this.stack[--d]\n      }\n    }\n    for (let i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i])\n    return this.bufferNode = new BufferNode(this.buffer, result, this.index)\n  }\n\n  /// Get the [tree](#common.Tree) that represents the current node, if\n  /// any. Will return null when the node is in a [tree\n  /// buffer](#common.TreeBuffer).\n  get tree(): Tree | null {\n    return this.buffer ? null : this._tree.node\n  }\n}\n\nfunction hasChild(tree: Tree): boolean {\n  return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch))\n}\n\nconst enum Balance { BranchFactor = 8 }\n\nconst enum SpecialRecord {\n  Reuse = -1,\n  ContextChange = -3,\n  LookAhead = -4\n}\n\nfunction buildTree(data: BuildData) {\n  let {buffer, nodeSet,\n       maxBufferLength = DefaultBufferLength,\n       reused = [],\n       minRepeatType = nodeSet.types.length} = data\n  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer as BufferCursor\n  let types = nodeSet.types\n\n  let contextHash = 0, lookAhead = 0\n\n  function takeNode(parentStart: number, minPos: number,\n                    children: (Tree | TreeBuffer)[], positions: number[],\n                    inRepeat: number) {\n    let {id, start, end, size} = cursor\n    let lookAheadAtStart = lookAhead\n    while (size < 0) {\n      cursor.next()\n      if (size == SpecialRecord.Reuse) {\n        let node = reused[id]\n        children.push(node)\n        positions.push(start - parentStart)\n        return\n      } else if (size == SpecialRecord.ContextChange) { // Context change\n        contextHash = id\n        return\n      } else if (size == SpecialRecord.LookAhead) {\n        lookAhead = id\n        return\n      } else {\n        throw new RangeError(`Unrecognized record size: ${size}`)\n      }\n      ;({id, start, end, size} = cursor)\n    }\n\n    let type = types[id], node, buffer: {size: number, start: number, skip: number} | undefined\n    let startPos = start - parentStart\n    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n      // Small enough for a buffer, and no reused nodes inside\n      let data = new Uint16Array(buffer.size - buffer.skip)\n      let endPos = cursor.pos - buffer.size, index = data.length\n      while (cursor.pos > endPos)\n        index = copyToBuffer(buffer.start, data, index)\n      node = new TreeBuffer(data, end - buffer.start, nodeSet)\n      startPos = buffer.start - parentStart\n    } else { // Make it a node\n      let endPos = cursor.pos - size\n      cursor.next()\n      let localChildren: (Tree | TreeBuffer)[] = [], localPositions: number[] = []\n      let localInRepeat = id >= minRepeatType ? id : -1\n      let lastGroup = 0, lastEnd = end\n      while (cursor.pos > endPos) {\n        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n          if (cursor.end <= lastEnd - maxBufferLength) {\n            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart)\n            lastGroup = localChildren.length\n            lastEnd = cursor.end\n          }\n          cursor.next()\n        } else {\n          takeNode(start, endPos, localChildren, localPositions, localInRepeat)\n        }\n      }\n      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)\n        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart)\n      localChildren.reverse(); localPositions.reverse()\n\n      if (localInRepeat > -1 && lastGroup > 0) {\n        let make = makeBalanced(type)\n        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make)\n      } else {\n        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end)\n      }\n    }\n\n    children.push(node)\n    positions.push(startPos)\n  }\n\n  function makeBalanced(type: NodeType) {\n    return (children: readonly (Tree | TreeBuffer)[], positions: readonly number[], length: number) => {\n      let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp\n      if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n        if (!lastI && last.type == type && last.length == length) return last\n        if (lookAheadProp = last.prop(NodeProp.lookAhead))\n          lookAhead = positions[lastI] + last.length + lookAheadProp\n      }\n      return makeTree(type, children, positions, length, lookAhead)\n    }\n  }\n\n  function makeRepeatLeaf(children: (Tree | TreeBuffer)[], positions: number[], base: number, i: number,\n                          from: number, to: number, type: number, lookAhead: number) {\n    let localChildren = [], localPositions = []\n    while (children.length > i) { localChildren.push(children.pop()!); localPositions.push(positions.pop()! + base - from) }\n    children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to))\n    positions.push(from - base)\n  }\n\n  function makeTree(type: NodeType,\n                    children: readonly (Tree | TreeBuffer)[],\n                    positions: readonly number[], length: number,\n                    lookAhead: number = 0,\n                    props?: readonly [number | NodeProp<any>, any][]) {\n    if (contextHash) {\n      let pair: [number | NodeProp<any>, any] = [NodeProp.contextHash, contextHash]\n      props = props ? [pair].concat(props) : [pair]\n    }\n    if (lookAhead > 25) {\n      let pair: [number | NodeProp<any>, any] = [NodeProp.lookAhead, lookAhead]\n      props = props ? [pair].concat(props) : [pair]\n    }\n    return new Tree(type, children, positions, length, props)\n  }\n\n  function findBufferSize(maxSize: number, inRepeat: number) {\n    // Scan through the buffer to find previous siblings that fit\n    // together in a TreeBuffer, and don't contain any reused nodes\n    // (which can't be stored in a buffer).\n    // If `inRepeat` is > -1, ignore node boundaries of that type for\n    // nesting, but make sure the end falls either at the start\n    // (`maxSize`) or before such a node.\n    let fork = cursor.fork()\n    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength\n    let result = {size: 0, start: 0, skip: 0}\n    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n      let nodeSize = fork.size\n      // Pretend nested repeat nodes of the same type don't exist\n      if (fork.id == inRepeat && nodeSize >= 0) {\n        // Except that we store the current state as a valid return\n        // value.\n        result.size = size; result.start = start; result.skip = skip\n        skip += 4; size += 4\n        fork.next()\n        continue\n      }\n      let startPos = fork.pos - nodeSize\n      if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break\n      let localSkipped = fork.id >= minRepeatType ? 4 : 0\n      let nodeStart = fork.start\n      fork.next()\n      while (fork.pos > startPos) {\n        if (fork.size < 0) {\n          if (fork.size == SpecialRecord.ContextChange) localSkipped += 4\n          else break scan\n        } else if (fork.id >= minRepeatType) {\n          localSkipped += 4\n        }\n        fork.next()\n      }\n      start = nodeStart\n      size += nodeSize\n      skip += localSkipped\n    }\n    if (inRepeat < 0 || size == maxSize) {\n      result.size = size; result.start = start; result.skip = skip\n    }\n    return result.size > 4 ? result : undefined\n  }\n\n  function copyToBuffer(bufferStart: number, buffer: Uint16Array, index: number): number {\n    let {id, start, end, size} = cursor\n    cursor.next()\n    if (size >= 0 && id < minRepeatType) {\n      let startIndex = index\n      if (size > 4) {\n        let endPos = cursor.pos - (size - 4)\n        while (cursor.pos > endPos)\n          index = copyToBuffer(bufferStart, buffer, index)\n      }\n      buffer[--index] = startIndex\n      buffer[--index] = end - bufferStart\n      buffer[--index] = start - bufferStart\n      buffer[--index] = id\n    } else if (size == SpecialRecord.ContextChange) {\n      contextHash = id\n    } else if (size == SpecialRecord.LookAhead) {\n      lookAhead = id\n    }\n    return index\n  }\n\n  let children: (Tree | TreeBuffer)[] = [], positions: number[] = []\n  while (cursor.pos > 0) takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1)\n  let length = data.length ?? (children.length ? positions[0] + children[0].length : 0)\n  return new Tree(types[data.topID], children.reverse(), positions.reverse(), length)\n}\n\nconst nodeSizeCache: WeakMap<Tree, number> = new WeakMap\nfunction nodeSize(balanceType: NodeType, node: Tree | TreeBuffer): number {\n  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1\n  let size = nodeSizeCache.get(node)\n  if (size == null) {\n    size = 1\n    for (let child of node.children) {\n      if (child.type != balanceType || !(child instanceof Tree)) {\n        size = 1\n        break\n      }\n      size += nodeSize(balanceType, child)\n    }\n    nodeSizeCache.set(node, size)\n  }\n  return size\n}\n\nfunction balanceRange(\n  // The type the balanced tree's inner nodes.\n  balanceType: NodeType,\n  // The direct children and their positions\n  children: readonly (Tree | TreeBuffer)[],\n  positions: readonly number[],\n  // The index range in children/positions to use\n  from: number, to: number,\n  // The start position of the nodes, relative to their parent.\n  start: number,\n  // Length of the outer node\n  length: number,\n  // Function to build the top node of the balanced tree\n  mkTop: ((children: readonly (Tree | TreeBuffer)[], positions: readonly number[], length: number) => Tree) | null,\n  // Function to build internal nodes for the balanced tree\n  mkTree: (children: readonly (Tree | TreeBuffer)[], positions: readonly number[], length: number) => Tree\n): Tree {\n  let total = 0\n  for (let i = from; i < to; i++) total += nodeSize(balanceType, children[i])\n\n  let maxChild = Math.ceil((total * 1.5) / Balance.BranchFactor)\n  let localChildren: (Tree | TreeBuffer)[] = [], localPositions: number[] = []\n  function divide(children: readonly (Tree | TreeBuffer)[], positions: readonly number[],\n                  from: number, to: number, offset: number) {\n    for (let i = from; i < to;) {\n      let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i])\n      i++\n      for (; i < to; i++) {\n        let nextSize = nodeSize(balanceType, children[i])\n        if (groupSize + nextSize >= maxChild) break\n        groupSize += nextSize\n      }\n      if (i == groupFrom + 1) {\n        if (groupSize > maxChild) {\n          let only = children[groupFrom] as Tree // Only trees can have a size > 1\n          divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset)\n          continue\n        }\n        localChildren.push(children[groupFrom])\n      } else {\n        let length = positions[i - 1] + children[i - 1].length - groupStart\n        localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree))\n      }\n      localPositions.push(groupStart + offset - start)\n    }\n  }\n  divide(children, positions, from, to, 0)\n  return (mkTop || mkTree)(localChildren, localPositions, length)\n}\n"],"names":[],"mappings":"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"}